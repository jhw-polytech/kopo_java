package kr.ac.kopo.day04.exam;

/*
5. 2 ~ 100사이의 소수를 출력하는 코드를 작성

	< 2 ~ 100사이의 소수 출력 >
	2 3 5 7 11 13 17 … 97
	
	
	* < 교수님이 말씀해주신 알고리즘 >
	*
	* 1) 배열 첫번째 수 n은 무조건 소수 ---> n의 배수 소거 가능하므로 0으로 변환
	* 2) 같은 원리로 어떤 수 m이 소수라면 ---> m의 배수 소거 가능하므로 0으로 변환
	* 3) 완료되고 나면 배열에서 0이 아닌 수만 순서대로 출력  
	
*/

/*
	제가 생각했던 그 방식의 코드는 아닌거 같아요..
	다시 생각을 해봅시다
	수업시간에 코드 다시 설명해드릴게요 ^^
	수고하셨어요
*/

public class Day04Exam05 {

	public static void main(String[] args) {

		// 배열생성(배열이 2부터 시작하므로 크기는 99)
		int[] arr = new int[99];

		// 배열주소를 옮겨가기 위한 인덱스 변수 생성
		int index = 0;

		// 생성한 배열에 2~100사이 정수 순서대로 저장
		for (int i = 2; i <= 100; i++) {
			arr[i - 2] = i;
		}

		// 소수 2의 배수에 해당하는 수는 0으로 변환
		for (int i = 1; i < 99; i++) { // arr[1] ~ arr[99]까지 반복문을 돌려
			if (arr[i] % 2 == 0) { // 2로 나눈 나머지가 0일 때
				arr[i] = 0; // 0으로 변환
			}
		}


		// 1과 자신을 제외한 정수 중에 나눠지는 수가 있는지 확인
		while (index < 99) {

			if (index > 1) {

				for (int i = 2; i < arr[index] - 1; i++) {

		
//교수님의 가이드라인과 일치하는 방법이 아닌데, 아직 명확히 풀리지 않아 일단 이 방법으로 풀었습니다.
//더 고민해보고 말씀주신 알고리즘 솔루션을 찾으면 재업로드 하겠습니다.
//--------------------------------------------------------------------------------
					// 나눠지는 수가 있으면(소수X) 0으로 변환
					if (arr[index] % i == 0) {

						arr[index] = 0;

					}
					
//--------------------------------------------------------------------------------

				}

			}

			index++;
		}

		// 인덱스 초기화
		index = 0;

		System.out.println("< 2 ~ 100사이의 소수 출력 >");

		// 소수, 즉 0이 아닌 수만 출력
		while (index < 99) {

			if (arr[index] != 0) {
				System.out.print(arr[index] + " ");
			}

			index++;
		}

	}

}
